.flexContainer{
    margin: 10px; padding: 15px; border-radius: 25px; background-color: #a4a4a4;
    display: flex;
}
.flexContainer .flexItem{
    margin: 10px; padding: 20px; color: white; text-align: center; border-radius: 25px;
    background-color: black;
}
.flexContainer.test{
    width: 48%; display: inline-flex; box-sizing: border-box;
}
.flexContainer.direction{
    flex-direction: column-reverse;
    /* 
        flex-direction :
        flex-direction 속성은 flexContainer의 주축(main Axis) 방향을 설정한다.

        row (ltr), row-reverse(rtl), column(ttb), column-reverse(btt)
    */
}
.flexContainer.wrap{
    flex-wrap: wrap-reverse;
    /* 
        flex-wrap :
        flex-wrap 속성은 flexContainer의 width보다 flexItem들의 width 합계가 큰 경우 한 줄로 나오게 할 것인가?
        아니면 여러줄로 개행 되게 할 것인가 를 결정.

        nowrap(개행불허. 1행 모두배치. default. flexItem width 가능한 범위까지 자동축소)
        wrap(width 초과시 개행 item width 설정시 %, max,min,px 등을 설정 하여 원하는 타이밍 가능.)
        wrap-reverse(wrap + 역배치)
    */
}
.flexContainer.wrap .flexItem{
    width: 500px;
}
.flexContainer.flow{
    flex-flow: row wrap;
}
/* 
    flex-flow:
    direction 과 wrap을 줄여 쓸 수(shorthand)있다.
    flex-flow: <flex-direction> | <flex-wrap>;
*/
.flexContainer.flow .flexItem{
    width: 33.33%; max-width: 500px; min-width: 300px;
}
.flexContainer[class$='Content']{
    padding: 0;
}
.flexContainer[class$='Content'] .flexItem{
    margin: 0;
}
.flexContainer.justifyContent{
    justify-content: space-evenly;
    /* 
        justify-content : 
        flex container의 main axis를 기준으로 flexItem을 수평 정렬한다.
        
        flex-start (flexItem을 좌측 기준정렬)
        flex-end (flexItem을 우측 기준정렬)
        center (flexItem을 가운데 기준정렬)
        space-between (flexItem 중 처음은 좌측기준, 마지막은 우측기준, 나머지는 동일간격으로 정렬)
        space-around (모든 flexItem은 처음,마지막 사이를  동일간격으로 정렬 외 나머지 배치)
        space-evenly (여유 공간을 flex 항목 사이의 공간 및 시작선 및 끝선과 flex 항목 간의 공간에 모두 균등하게 배분.)
    */
}
.flexContainer.alignContent{
    height: 400px; flex-wrap: wrap; justify-content: space-between; align-content: space-between;

    /* 
        ! align(yAxis)
        align-content: (창조절필요)
        flex container의 cross axis를 기준으로 flexItem을 수직 정렬한다.
        
        stretch (flexItem 행 간격을 균등하게. cross Start에서 End까지 꽉찬 높이.)
        flex-start (flexItem 행 간격 없이 (stack))
        flex-end (flexContainer의 cross end 기준으로 행 간격 없이)
        center (flexContainer의 cross axis 중앙 기준으로 행 간격 없이)
        space-between (첫 행은 flexContainer cross start 기준, 마지막 행은 flexContainer cross end 기준, 나머지 행 균등하게)
        space-around (모든 flexItem은 처음,마지막 사이를  동일간격으로 정렬 외 나머지 배치)
        space-evenly (여유 공간을 flex 항목 사이의 공간 및 시작선 및 끝선과 flex 항목 간의 공간에 모두 균등하게 배분.) 
    */
}
.flexContainer.alignContent .flexItem{
    width: 33.33%; max-width:500px; min-width: 300px;
}

.flexContainer.justifyItems{
    background-color: yellow; width: 300px; justify-items: stretch;
    display: grid; flex-flow: row wrap;
    /* 
        ? justify-items:
        * flexItem을 parent Width기준으로 flexContainer의 수평 방향으로 정렬한다.
        * justify-items 속성은 모든 flexitem에 적용된다.
    
        * stretch (cross Start 에서 End까지 꽉찬 너비)
        * flex-start (cross Start 기준으로 정렬.)
        * flex-end (cross End 기준으로 정렬.)
        * center (flexContainer의 주축 중앙에 정렬.)
    */
}
.flexContainer.justifyItems:hover{
    justify-items: flex-end;
}
.flexContainer.alignItems{
    align-items: baseline; background-color: orange;
    /* 
        ? align-items : 
        * flexItem을 line-height(contentHeight)기준으로 flexContainer의 수직 방향으로 정렬한다.
        * align-items 속성은 모든 flexItem에 적용된다.

        * stretch (cross Start 에서 End까지 꽉찬 높이)
        * flex-start (cross Start 기준으로 정렬.)
        * flex-end (cross End 기준으로 정렬.)
        * center  (flexContainer의 주축 중앙에 정렬.)
        * baseline (안의 컨텐츠 End 기준으로 정렬.)
    */
}
.flexContainer.alignItems:hover{
    align-items: flex-end;
}
.flexContainer.alignItems .flexItem:first-of-type{
    line-height: 50px;
}
.flexContainer.alignItems .flexItem:nth-of-type(2){
    line-height: 100px;
}
.flexContainer.justifySelf{
    width: 220px; display: grid;
}
.flexContainer.justifySelf .flexItem:first-of-type{
    justify-self: stretch;
    /* 
        ?justify-self
        * stretch - 내부 공간 기준으로 자신의 너비 맞추기
        * flex-start - 내부 공간 기준으로 자신의 위치를 좌측으로 맞추기
        * flex-end - 내부 공간 기준으로 자신의 위치를 우측으로 맞추기
    */
}
.flexContainer.justifySelf:hover .flexItem:first-of-type{
    justify-self: flex-start;
}
.flexContainer.alignSelf .flexItem:first-of-type{
    align-self: flex-start;
    /* 
        ?align-self
        * stretch - 요소들중 가장 높은 것을 기준으로 자신의 높이를 맞추기
        * flex-start - 요소들중 가장 높은 것의 윗선을 기준으로 자신을 맞추기
        * center - 요소들중 가장 높은 것의 중앙을 기준으로 자신을 맞추기
        * flex-end - 요소들중 가장 높은 것의 밑선을 기준으로 자신을 맞추기
    */
}
.flexContainer.alignSelf:hover .flexItem:first-of-type{
    align-self: flex-end;
}
.flexContainer.alignSelf .flexItem:nth-of-type(2){
    line-height: 100px;
}
.flexContainer.orderItem .flexItem.order1{
    order: 2; background-color: lightgreen; color: green; font-weight: bold;
}
.flexContainer.orderItem .flexItem.order2{
    order: -1; background-color: lightpink; color: deeppink; font-weight: bold;
}
.flexContainer.orderItem .flexItem.order3{
    order: 1; background-color: lightblue; color: midnightblue; font-weight: bold;
}