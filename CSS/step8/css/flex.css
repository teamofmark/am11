.flexContainer{
    margin: 10px; padding: 15px; border-radius: 23px;
    background-color: #a4a4a4; display: flex;
}
.flexItem{
    margin: 10px; padding: 20px; color: white;
    text-align: center; border-radius: 27px;
    background-color: black;
}
/* 
    기본
    display: flex;
    justify-content: space-around; ( flexItem 주변 동일 간격 유지 정렬 )
    ! 1. 부모 요소는 flex 혹은 inline-flex 로 지정되어야 한다.
    ? flex = 부모요소가 block 인 경우, inline-flex = 부모요소가 inline일 경우
    * 그러면 자동으로 이하 자식요소는 모두 flexItem이 된다.
*/

.flexContainer.direction{
    flex-direction: row-reverse;
}
/* 
? flex-direction : 
* flex-direction 속성은 flexContainer의 주축(main axis) 방향을 설정한다.

! row (ltr), row-reverse(rtl), column(TopToBottom), column-reverse(BottomToTop)
*/
.flexContainer.wrap{
    flex-wrap: wrap-reverse;
}
/* 
    ? flex-wrap : 
    * flex-wrap속성은 flexContainer의 width보다 flexItem들의 width 합계가 큰 경우 한 줄로 나오게 할 것인지, 여러줄로 나오게 할 것인지 결정.

    ! nowrap(개행불허. 1행 모두배치. default. flexItem width 자동축소)
    ! wrap(width 초과시 개행)
    ! wrap-reverse(개행하되 역배치)
*/

.flexContainer.wrap .flexItem,
.flexContainer.flow .flexItem{
    width: 500px;
}
.flexContainer.flow{
    flex-flow: row wrap;
    /* 
        ? flex-flow : 
        * direction 과 wrap 을 줄여 쓸 수(shorthand)있다.

        !<flex-direction> | <flex-wrap>;
    */
}
.flexContainer.justifyContent{
    justify-content: space-around;
    /* 
        ? justify-content : 
        ! flex container의 main axis를 기준으로 flexItem을 수평 정렬한다.
        
        * flex-start (flexItem을 좌측 기준정렬)
        * flex-end (flexItem을 우측 기준정렬)
        * center (flexItem을 가운데 기준정렬)
        * space-between (flexItem 중 처음은 좌측기준, 마지막은 우측기준, 나머지는 동일간격으로 정렬)
        * space-around (모든 flexItem은 기준없이 동일간격으로 정렬)
        * space-evenly (여유 공간을 flex 항목 사이의 공간 및 시작선 및 끝선과 flex 항목 간의 공간에 모두 균등하게 배분.)
    */
}