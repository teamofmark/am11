.flexContainer{
    margin: 10px; padding: 15px; border-radius: 23px;
    background-color: #a4a4a4; display: flex;
}
/* 
        기본
        ! 1. 부모 요소는 flex 혹은 inline-flex 로 지정되어야 한다.
        ? flex = 부모요소가 block 인 경우, inline-flex = 부모요소가 inline일 경우
        * 그러면 자동으로 이하 자식요소는 모두 flexItem이 된다.
*/

.flexItem{
    margin: 10px; padding: 20px; color: white; background-color: black;
    text-align: center; border-radius: 27px;
}

.flexContainer.direction{
    flex-direction: column-reverse;
    /* 
    flex-direction : 
    flex-direction 속성은 flexContainer의 주축(main axis) 방향을 설정한다.

    row (ltr), row-reverse(rtl), column(TopToBottom), column-reverse(BottomToTop)
    */
}

.flexContainer.wrap{
    flex-wrap: nowrap;
    /* 
        flex-wrap : 
        flex-wrap 속성은 flexContainer의 width보다 flexItem들의 width의 합계가 더 큰 경우, 한줄로 표현할 것인지, 여러줄로 표현할 것인지를 지정한다. 

        nowrap(개행불허. 1행 모두배치. default. flexItem width 자동축소)
        wrap(width 초과시 개행)
        wrap-reverse(개행하되 역배치)
        
    */
}

.flexContainer.flow{
    flex-flow: row wrap;
    /* 
        flex-flow : 
        direction 과 wrap 을 줄여 쓸 수(shorthand)있다.

        ! <flex-direction> | <flex-wrap>;
        
    */
}
.flexContainer.justify{
    justify-content: space-around;
    /* 
        justify-content : 
        flex container의 main axis를 기준으로 flexItem을 수평 정렬한다.
        
        * flex-start (flexItem을 좌측 기준정렬)
        * flex-end (flexItem을 우측 기준정렬)
        * center (flexItem을 가운데 기준정렬)
        * space-between (flexItem 중 처음은 좌측기준, 마지막은 우측기준, 나머지는 동일간격으로 정렬)
        * space-around (모든 flexItem은 기준없이 동일간격으로 정렬)
    */
}
.flexContainer.alignItems{
    height: 200px;
    align-items: stretch;
    /* 
        align-items : 
        flexItem을 flexContainer의 수직 방향으로 정렬한다.
        align-items 속성은 모든 flexItem에 적용된다.

        stretch (cross Start 에서 End까지 꽉찬 높이)
        flex-start (cross Start 기준으로 정렬.)
        flex-end (cross End 기준으로 정렬.)
        center  (flexContainer의 주축 중앙에 정렬.)
        baseline (안의 컨텐츠 End 기준으로 정렬.)
    */
}

.flexContainer.alignContent{
    height: 400px;
    flex-wrap: wrap; justify-content: flex-start;
    align-content: space-around;
}
.flexContainer.alignContent .flexItem{
    margin:0;
}
/* 
    ! justify와 유사
    align-content:
    flex container의 cross axis를 기준으로 flexItem을 수직 정렬한다.
    
    stretch (flexItem 행 간격을 균등하게. cross Start에서 End까지 꽉찬 높이.)
    flex-start (flexItem 행 간격 없이 (stack))
    flex-end (flexContainer의 cross end 기준으로 행 간격 없이)
    center (flexContainer의 cross axis 중앙 기준으로 행 간격 없이)
    space-between (첫 행은 flexContainer cross start 기준, 마지막 행은 flexContainer cross end 기준, 나머지 행 균등하게)
    space-around (flexContainer 공간안에 모든 행 균등하게)
     
*/

/* !이하 item */

.flexContainer.orderItem .flexItem.order1{
    order: -1;
}
.flexContainer.orderItem .flexItem.order2{
    order: 1;
}
.flexContainer.orderItem .flexItem.order3{
    order: 0;
}
/* 
    order:
    flex container의 flexItem을 0(default)을 기본으로 적은 수일수록(음수가능) 먼저 배치한다. 
*/

.flexContainer.flexShortHand{
    width: 300px;
    margin:0; padding:0;
}
.flexContainer.flexShortHand .flexItem{
    word-break: break-all; margin:0; padding:0;
}

.flexContainer.flexShortHand .flexItem:first-child{
    flex-grow: 2;
    flex-basis: 0;
}
.flexContainer.flexShortHand .flexItem:first-child~*{
    flex-grow: 1;
    flex-basis: 0;
}
/* 
    grow:
    ! item의 확장비를 정한다. 기본값은 0으로 설정된다. 즉 빈 공간을 알아서 확장하여 채우지 않는다.
    * 음수는 허용되지 않고, 양수를 입력 하였을 때 총 증가 내부팽창지수(grow합산)의 너비 중 입력된 비율 만큼 너비를 가질 수 있다.
    * 또한 max-width가 설정되면 해당 수치를 넘지 않는다.
    * 예를 들어 item이 3개이고 item들에게 grow가 1이 부여된다면 각각 1/3의 너비를 갖게된다.

    ? ex.1 >만약 전체 너비(300px)의 item 3개에 개별적으로 grow가 부여되었다면?
    * .flexItem:first-child{flex-grow:2} // 0+(300/4)*2=150
    * .flexItem:first-child~*{flex-grow:1} // 0+(300/4)*1=75
*/